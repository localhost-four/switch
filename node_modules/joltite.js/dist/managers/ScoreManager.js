"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseManager_1 = require("./BaseManager");
const constants_1 = require("../util/constants");
/**
 * Manager responsible for managing the API methods of scores.
 */
class ScoreManager extends BaseManager_1.BaseManager {
    /**
     * Adds a score for a user or guest.
     * @param score This is a string value associated with the score.
     * @param sort This is a numerical sorting value associated with the score. All sorting will be based on this number.
     * @param options Extra score options.
     */
    add(score, sort, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let endpoint = constants_1.Endpoints.scores.add(score, sort);
            endpoint += this.guestOrUser(options.guest);
            if (options.extraData) {
                endpoint += `&extra_data=${options.extraData}`;
            }
            if (options.tableId) {
                endpoint += `&table_id=${options.tableId}`;
            }
            return (yield this.request(endpoint));
        });
    }
    /**
     * Returns a list of scores either for a user or globally for a game.
     *
     * @param query The query options for fetching scores.
     */
    fetch(query = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { username, token } = this.client.authCredentials;
            let endpoint = constants_1.Endpoints.scores.fetch();
            if (query.userOnly) {
                endpoint += `&username=${username}&user_token=${token}`;
            }
            else if (query.guest) {
                endpoint += `&guest=${query.guest}`;
            }
            if (query.betterThan) {
                endpoint += `&better_than=${query.betterThan}`;
            }
            else if (query.worseThan) {
                endpoint += `&worse_than=${query.worseThan}`;
            }
            if (query.tableId) {
                endpoint += `&table_id=${query.tableId}`;
            }
            if (query.limit) {
                endpoint += `&limit=${query.limit}`;
            }
            return (yield this.request(endpoint));
        });
    }
    /**
     * Returns the rank of a particular score on a score table.
     *
     * @param sort This is a numerical sorting value that is represented by a rank on the score table.
     * @param tableId The ID of the score table from which you want to get the rank.
     */
    getRank(sort, tableId) {
        return __awaiter(this, void 0, void 0, function* () {
            let endpoint = constants_1.Endpoints.scores.rank(sort);
            if (tableId) {
                endpoint += `&table_id=${tableId}`;
            }
            const response = (yield this.request(endpoint));
            return response;
        });
    }
    /**
     * Returns a list of high score tables for a game.
     */
    tables() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = (yield this.request(constants_1.Endpoints.scores.tables()));
            return response;
        });
    }
    guestOrUser(guest) {
        const { username, token } = this.client.authCredentials;
        return guest
            ? `&guest=${guest}`
            : `&username=${username}&user_token=${token}`;
    }
}
exports.ScoreManager = ScoreManager;
