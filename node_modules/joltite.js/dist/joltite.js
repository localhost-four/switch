const joltite = (function (exports) {
    'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    const apiBase = 'https://api.gamejolt.com/api/game/v1_2';
    /**
     * Contains all user endpoints.
     */
    const users = {
        auth: (username, token) => `/users/auth/?username=${username}&user_token=${token}`,
        fetch: (userIds) => `/users/?user_id=${userIds.join()}`,
    };
    /**
     * Contains all session endpoints.
     */
    const sessions = {
        open: (username, token) => `/sessions/open/?username=${username}&user_token=${token}`,
        ping: (username, token, status) => `/sessions/ping/?username=${username}&user_token=${token}&status=${status}`,
        close: (username, token) => `/sessions/close/?username=${username}&user_token=${token}`,
    };
    /**
     * Contains all score endpoints.
     */
    const scores = {
        add: (score, sort) => `/scores/add/?score=${score}&sort=${sort}`,
        fetch: () => `/scores/?`,
        tables: () => `/scores/tables/?`,
        rank: (sort) => `/scores/get-rank/?sort=${sort}`,
    };
    /**
     * Contains all trophy endpoints.
     */
    const trophies = {
        add: (username, token, trophyId) => `/trophies/add-achieved/?username=${username}&user_token=${token}&trophy_id=${trophyId}`,
        remove: (username, token, trophyId) => `/trophies/remove-achieved/?username=${username}&user_token=${token}&trophy_id=${trophyId}`,
        fetch: (username, token) => `/trophies/?username=${username}&user_token=${token}`,
    };
    /**
     * Contains all data storage endpoints.
     */
    const dataStorage = {
        fetch: (key) => `/data-store/?key=${key}`,
        set: (key, data) => `/data-store/set/?key=${key}&data=${data}`,
        update: (key, operation, value) => `/data-store/update/?key=${key}&operation=${operation}&value=${value}`,
        remove: (key) => `/data-store/remove/?key=${key}`,
        getKeys: () => `/data-store/get-keys/?`,
    };
    /**
     * Contains all friends endpoints.
     */
    const friends = {
        fetch: (username, token) => `/friends/?username=${username}&user_token=${token}`,
    };
    /**
     * Contains all time endpoints.
     */
    const time = {
        fetch: () => `/time/?`,
    };
    /**
     * Contains all api endpoints.
     */
    const Endpoints = {
        users,
        sessions,
        scores,
        trophies,
        dataStorage,
        friends,
        time,
    };
    const isBrowser = typeof window !== 'undefined';

    /**
     * Defines the allowed Http methods.
     */
    var HttpMethods;
    (function (HttpMethods) {
        HttpMethods["GET"] = "GET";
        HttpMethods["POST"] = "POST";
    })(HttpMethods || (HttpMethods = {}));

    /**
     * The API can return information in different formats.
     * If you don't use the format parameter for a request URL, json will be used as the default format.
     */
    var Formats;
    (function (Formats) {
        /**
         * Outputs data as a JSON string.
         */
        Formats["Json"] = "json";
        /**
         * This is a special format used when a certain function has to output a single chunk of data.
         */
        Formats["Dump"] = "dump";
    })(Formats || (Formats = {}));

    /**
     * Creates a sha-1 hash using the Web Crypto API.
     *
     * @param message The message to hash.
     */
    function subtleCrypto(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const encoder = new TextEncoder();
            const hashBuffer = yield crypto.subtle.digest('SHA-1', encoder.encode(message));
            const hashData = Array.from(new Uint8Array(hashBuffer));
            return hashData.map((b) => b.toString(16).padStart(2, '0')).join('');
        });
    }
    /**
     * Creates a sha-1 hash using the node crypto module.
     *
     * @param message The message to hash.
     */
    function nodeCrypto(message) {
        const hash = require('crypto').createHash('sha1');
        hash.update(message);
        return hash.digest('hex');
    }
    /**
     * Creates a sha-1 hash.
     *
     * @param message The message to hash.
     */
    function SHA1(message) {
        return __awaiter(this, void 0, void 0, function* () {
            return isBrowser && window.crypto.subtle
                ? subtleCrypto(message)
                : nodeCrypto(message);
        });
    }

    const fetch = isBrowser ? window.fetch : require('node-fetch');
    /**
     * Represents an API request.
     */
    class APIRequest {
        /**
         * @param client The Game Jolt client.
         * @param path The path of the API request.
         * @param request The request options.
         */
        constructor(client, path, request = {}) {
            this.client = client;
            this.method = request.method || HttpMethods.GET;
            this.path = path;
            this.body = request.body;
            this.format = request.format || Formats.Json;
        }
        /**
         * Sends a request to the API.
         */
        make() {
            return __awaiter(this, void 0, void 0, function* () {
                let url = `${this.path}&game_id=${this.client.gameId}`;
                if (this.format !== Formats.Json) {
                    url += `&format=${this.format}`;
                }
                const signature = yield this.signature(url);
                return fetch(`${url}&signature=${signature}`, {
                    method: this.method,
                    body: this.body,
                });
            });
        }
        signature(url) {
            return SHA1(url + this.client.privateKey);
        }
    }

    /**
     * Base manager responsible for managing
     * the API methods of a data model.
     */
    class BaseManager {
        /**
         * @param client The Game Jolt client.
         */
        constructor(client) {
            this.client = client;
        }
        /**
         * Sends a request to the API.
         * @param url The url of the api request.
         * @param request The request options.
         */
        request(url, request = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                const endpoint = apiBase + encodeURI(url);
                const apiRequest = new APIRequest(this.client, endpoint, request);
                const apiResponse = yield apiRequest.make();
                let response;
                if (apiRequest.format === Formats.Json) {
                    const json = (yield apiResponse.json()).response;
                    json.success = json.success === 'true';
                    response = json;
                }
                else {
                    response = apiResponse.text();
                }
                return response;
            });
        }
    }

    /**
     * Manager responsible for managing the API methods of users.
     */
    class UserManager extends BaseManager {
        /**
         * Authenticates the user's information.
         * This should be done before you make any calls for the user,
         * to make sure the user's credentials (username and token) are valid.
         *
         * @param authCredentials The credentials required to authenticate a user.
         */
        auth(authCredentials) {
            return __awaiter(this, void 0, void 0, function* () {
                const { username, token } = authCredentials;
                const response = (yield this.request(Endpoints.users.auth(username, token)));
                return response;
            });
        }
        /**
         * Returns a user's data.
         *
         * @param users The ids of the users to fetch.
         */
        fetch(users) {
            return __awaiter(this, void 0, void 0, function* () {
                const ids = typeof users === 'number' ? [users] : users;
                const response = (yield this.request(Endpoints.users.fetch(ids)));
                return response;
            });
        }
    }

    /**
     * Manager responsible for managing the API methods of sessions.
     * Sessions are used to tell Game Jolt when a user is playing a game,
     * and what state they are in while playing (active or idle).
     */
    class SessionManager extends BaseManager {
        constructor() {
            super(...arguments);
            this.status = 'active';
        }
        /**
         * Sets the session status.
         */
        set isActive(active) {
            this.status = active ? 'active' : 'idle';
        }
        /**
         * Opens a game session for a particular user and allows you to tell Game Jolt
         * that a user is playing your game.
         */
        open() {
            return __awaiter(this, void 0, void 0, function* () {
                const { username, token } = this.client.authCredentials;
                const response = (yield this.request(Endpoints.sessions.open(username, token)));
                if (response.success) {
                    const pingInterval = 30 * 1000;
                    setInterval(() => this.ping(), pingInterval);
                }
                return response;
            });
        }
        /**
         * Pings an open session to tell the system that it's still active.
         * If the session hasn't been pinged within 120 seconds,
         * the system will close the session and you will have to open another one.
         */
        ping() {
            return __awaiter(this, void 0, void 0, function* () {
                const { username, token } = this.client.authCredentials;
                const response = (yield this.request(Endpoints.sessions.ping(username, token, this.status)));
                return response;
            });
        }
        /**
         * Closes the active session.
         */
        close() {
            return __awaiter(this, void 0, void 0, function* () {
                const { username, token } = this.client.authCredentials;
                const response = (yield this.request(Endpoints.sessions.close(username, token)));
                return response;
            });
        }
    }

    /**
     * Manager responsible for managing the API methods of scores.
     */
    class ScoreManager extends BaseManager {
        /**
         * Adds a score for a user or guest.
         * @param score This is a string value associated with the score.
         * @param sort This is a numerical sorting value associated with the score. All sorting will be based on this number.
         * @param options Extra score options.
         */
        add(score, sort, options = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                let endpoint = Endpoints.scores.add(score, sort);
                endpoint += this.guestOrUser(options.guest);
                if (options.extraData) {
                    endpoint += `&extra_data=${options.extraData}`;
                }
                if (options.tableId) {
                    endpoint += `&table_id=${options.tableId}`;
                }
                return (yield this.request(endpoint));
            });
        }
        /**
         * Returns a list of scores either for a user or globally for a game.
         *
         * @param query The query options for fetching scores.
         */
        fetch(query = {}) {
            return __awaiter(this, void 0, void 0, function* () {
                const { username, token } = this.client.authCredentials;
                let endpoint = Endpoints.scores.fetch();
                if (query.userOnly) {
                    endpoint += `&username=${username}&user_token=${token}`;
                }
                else if (query.guest) {
                    endpoint += `&guest=${query.guest}`;
                }
                if (query.betterThan) {
                    endpoint += `&better_than=${query.betterThan}`;
                }
                else if (query.worseThan) {
                    endpoint += `&worse_than=${query.worseThan}`;
                }
                if (query.tableId) {
                    endpoint += `&table_id=${query.tableId}`;
                }
                if (query.limit) {
                    endpoint += `&limit=${query.limit}`;
                }
                return (yield this.request(endpoint));
            });
        }
        /**
         * Returns the rank of a particular score on a score table.
         *
         * @param sort This is a numerical sorting value that is represented by a rank on the score table.
         * @param tableId The ID of the score table from which you want to get the rank.
         */
        getRank(sort, tableId) {
            return __awaiter(this, void 0, void 0, function* () {
                let endpoint = Endpoints.scores.rank(sort);
                if (tableId) {
                    endpoint += `&table_id=${tableId}`;
                }
                const response = (yield this.request(endpoint));
                return response;
            });
        }
        /**
         * Returns a list of high score tables for a game.
         */
        tables() {
            return __awaiter(this, void 0, void 0, function* () {
                const response = (yield this.request(Endpoints.scores.tables()));
                return response;
            });
        }
        guestOrUser(guest) {
            const { username, token } = this.client.authCredentials;
            return guest
                ? `&guest=${guest}`
                : `&username=${username}&user_token=${token}`;
        }
    }

    /**
     * Manager responsible for managing the API methods of trophies.
     */
    class TrophyManager extends BaseManager {
        constructor() {
            super(...arguments);
            /**
             * Trophies returned from the API. Populated when {@link TrophyManager#fetch} is called.
             */
            this.fetchedTrophies = [];
        }
        /**
         * Returns one trophy or multiple trophies.
         *
         * @param [achieved] Whether to fetch only achieved trophies.
         */
        fetch(achieved) {
            return __awaiter(this, void 0, void 0, function* () {
                const { username, token } = this.client.authCredentials;
                let endpoint = Endpoints.trophies.fetch(username, token);
                if (achieved) {
                    endpoint += `&achieved=${achieved}`;
                }
                const response = (yield this.request(endpoint));
                if (response && response.trophies) {
                    this.fetchedTrophies = response.trophies;
                }
                return response;
            });
        }
        /**
         * Returns one trophy or multiple trophies by Id.
         *
         * @param trophyIds The IDs of the trophies to fetch.
         */
        fetchById(trophyIds) {
            return __awaiter(this, void 0, void 0, function* () {
                const { username, token } = this.client.authCredentials;
                const ids = typeof trophyIds === 'number' ? [trophyIds] : trophyIds;
                const response = (yield this.request(`${Endpoints.trophies.fetch(username, token)}&trophy_id=${ids.join()}`));
                return response;
            });
        }
        /**
         * Sets a trophy as achieved for a particular user.
         *
         * @param trophyId The ID of the trophy to add for the user.
         */
        addAchieved(trophyId) {
            return __awaiter(this, void 0, void 0, function* () {
                const { username, token } = this.client.authCredentials;
                const response = (yield this.request(`${Endpoints.trophies.add(username, token, trophyId)}`));
                return response;
            });
        }
        /**
         * Remove a previously achieved trophy for a particular user.
         *
         * @param trophyId The ID of the trophy to remove from the user.
         */
        removeAchieved(trophyId) {
            return __awaiter(this, void 0, void 0, function* () {
                const { username, token } = this.client.authCredentials;
                const response = (yield this.request(`${Endpoints.trophies.remove(username, token, trophyId)}`));
                return response;
            });
        }
    }

    /**
     * Manager responsible for managing the API methods of data storage.
     */
    class DataStoreManager extends BaseManager {
        /**
         * Returns data from the data store.
         *
         * @param key The key of the data item you'd like to fetch.
         * @param [user] Whether to fetch user data store item.
         */
        fetch(key, user) {
            return __awaiter(this, void 0, void 0, function* () {
                const { username, token } = this.client.authCredentials;
                let endpoint = Endpoints.dataStorage.fetch(key);
                if (user) {
                    endpoint += `&username=${username}&user_token=${token}`;
                }
                const response = (yield this.request(endpoint));
                return response;
            });
        }
        /**
         * Sets data in the data store.
         *
         * @param key The key of the data item you'd like to set.
         * @param data The data you'd like to set.
         * @param [user] Whether to set a user data store item.
         */
        set(key, data, user) {
            return __awaiter(this, void 0, void 0, function* () {
                const { username, token } = this.client.authCredentials;
                let endpoint = Endpoints.dataStorage.set(key, data);
                if (user) {
                    endpoint += `&username=${username}&user_token=${token}`;
                }
                const response = (yield this.request(endpoint));
                return response;
            });
        }
        /**
         * Updates data in the data store.
         * @param key The key of the data item you'd like to update.
         * @param value	The value you'd like to apply to the data store item.
         * @param operation The operation you'd like to perform.
         * @param [user] Whether this is a user data store item.
         */
        update(key, value, operation, user) {
            return __awaiter(this, void 0, void 0, function* () {
                const { username, token } = this.client.authCredentials;
                let endpoint = Endpoints.dataStorage.update(key, operation, value);
                if (user) {
                    endpoint += `&username=${username}&user_token=${token}`;
                }
                const response = (yield this.request(endpoint));
                return response;
            });
        }
        /**
         * Removes data from the data store.
         *
         * @param key The key of the data item you'd like to remove.
         * @param [user] Whether to remove a user data store item.
         */
        remove(key, user) {
            return __awaiter(this, void 0, void 0, function* () {
                const { username, token } = this.client.authCredentials;
                let endpoint = Endpoints.dataStorage.remove(key);
                if (user) {
                    endpoint += `&username=${username}&user_token=${token}`;
                }
                const response = (yield this.request(endpoint));
                return response;
            });
        }
        /**
         * Returns either all the keys in the game's global data store, or all the keys in a user's data store.
         *
         * @param [user] Whether to fetch user data store item.
         * @param [pattern] The pattern to apply to the key names in the data store.
         */
        getKeys(user, pattern) {
            return __awaiter(this, void 0, void 0, function* () {
                const { username, token } = this.client.authCredentials;
                let endpoint = Endpoints.dataStorage.getKeys();
                if (user) {
                    endpoint += `&username=${username}&user_token=${token}`;
                }
                if (pattern) {
                    endpoint += `&pattern=${pattern}`;
                }
                const response = (yield this.request(endpoint));
                return response;
            });
        }
    }

    /**
     * Manager responsible for managing the API methods of user friends.
     */
    class FriendsManager extends BaseManager {
        /**
         * Returns the list of a user's friends.
         */
        fetch() {
            return __awaiter(this, void 0, void 0, function* () {
                const { username, token } = this.client.authCredentials;
                const response = (yield this.request(Endpoints.friends.fetch(username, token)));
                return response;
            });
        }
    }

    /**
     * Manager responsible for managing the API methods of time.
     */
    class TimeManager extends BaseManager {
        /**
         * Returns the time of the Game Jolt server.
         */
        fetch() {
            return __awaiter(this, void 0, void 0, function* () {
                const response = (yield this.request(Endpoints.time.fetch()));
                return response;
            });
        }
    }

    class GameJolt {
        /**
         * @param options The options to pass to the client.
         */
        constructor(options) {
            this.gameId = options.gameId;
            this.privateKey = options.privateKey;
            this.authCredentials = options.authCredentials || {
                username: '',
                token: '',
            };
            this.users = new UserManager(this);
            this.sessions = new SessionManager(this);
            this.scores = new ScoreManager(this);
            this.trophies = new TrophyManager(this);
            this.dataStorage = new DataStoreManager(this);
            this.friends = new FriendsManager(this);
            this.time = new TimeManager(this);
            if (options.authCredentials) {
                this.sessions.open();
            }
        }
        /**
         * Login to Game Jolt with username and token.
         *
         * @param credentials The user credentials for authentication.
         */
        login(credentials) {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.users.auth(credentials);
                if (response.success) {
                    this.authCredentials = credentials;
                    this.sessions.open();
                }
                return response;
            });
        }
        /**
         * Logout the current acive user.
         */
        logout() {
            return __awaiter(this, void 0, void 0, function* () {
                const response = yield this.sessions.close();
                if (response.success) {
                    this.authCredentials = {
                        username: '',
                        token: '',
                    };
                }
                return response;
            });
        }
    }

    /**
     * Contains valid data storage operations.
     */
    (function (DataStoreOperations) {
        DataStoreOperations["Add"] = "add";
        DataStoreOperations["Subtract"] = "subtract";
        DataStoreOperations["Multiply"] = "multiply";
        DataStoreOperations["Divide"] = "divide";
        DataStoreOperations["Append"] = "append";
        DataStoreOperations["Prepend"] = "prepend";
    })(exports.DataStoreOperations || (exports.DataStoreOperations = {}));

    exports.GameJolt = GameJolt;

    return exports;

}({}));
